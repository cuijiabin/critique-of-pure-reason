第四章ZooKeeper与Paxos

ApacheZooKeeper是由ApacheHadoop的子项目发展而来,于2010年11月正式成为了Apache的顶级项目。ZooKeeper为分布式应用提供了高效且可靠的分布式协调服务,提供了诸如统一命名服务、配置管理和分布式锁等分布式的基础服务。在解决分布式数据一致性方面,ZooKeeper并没有直接采用Paxos算法,而是采用了一种被称为B(ZooKeeperAtomicBroadcast)的一致性协议。

在本章中,我们将首先对ZooKeeper进行一个整体上的介绍,包括ZooKeeper的设计目标,由来以及它的基本概念,然后将会重点介绍ZAB这一ZooKeeper中非常重要的一致性协议。

4.1初ZooKeeper识
在本节中,我们会对ZooKeeper进行一个初步的介绍,从ZooKeeper是什么、Zookeeper的由来及其基本概念展开,同时会向读者介绍使用ZooKeeper来解决分布式一致性问题的优势。

4.1.1ZooKeeper介绍
ZooKeeper是一个开放源代码的分布式协调服务,由知名互联网公司雅虎创建,是GoogleChubby的开源实现ZooKeeper的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来,构成一个高效可靠的原语集,并以一系列简单易用的接口提供给用户使用。

ZooKeeper是什么
ZooKeeper是一个典型的分布式数据一致性的解决方案,分布式应用程序可以基于它实现诸如数据发布/了阅，负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能.ZooKeeper可以保证如下分布式一致性特性。

顺序一致性
从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到
ZooKeeper中去。

原子性
所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说。
要么整个集群所有机器都成功应用了某一个事务，要么都没有应用，一定不会出现
集群中部分机器应用了该事务，而另外一部分没有应用的情况。

单一视图（SingleSystemlmage）
无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。

可靠性
一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么么该事务所引起的
服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。

实时性
通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立
即从服务端上读取到这个事务变更后的最新数据状态，这里需要注意的是，
ZooKecper仪仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最
新的数据状态。

ZooKeeper的设计目标
ZooKeeper致力于提供一个高性能高可用,且具有严格的顺序访问控制能力(主要是写操作的严格顺序性)的分布式协调服务。高性能使得ZooKeeper能够应用于那些对系统吞吐有明确要求的大型分布式系统中,高可用使得分布式的单点问题得到了很好的解决,而严格的顺序访问控制使得客户端能够基于ZooKeeper实现一些复杂的同步原语下面我们来具体看一下ZooKeeper的四个设计目标。

目标一:简单的数据模型
ZooKeeper使得分布式程序能够通过一个共享的,树型结构的名字空间来进行相互协调。这里所说的树型结构的名字空间,是指ZooKeeper服务器内存中的一个数据模型,其由一系列被称为ZNode的数据节点组成,总的来说,其数据模型类似于一个文件系统,而ZNode之间的层级关系,就像文件系统的目录结构一样。不过和传统的磁盘文件系统不同的是,ZooKeeper将全量数据存储在内存中,以此来实现提高服务器吞吐、减少延迟的目的。关于Zookeeper的数据模型,将会在7.L.1节中做详细阐述。

目标二:可以构建集群
一个ZooKeeper集群通常由一组机器组成,一般3-5台机器就可以组成一个可用的ZooKeeper集群了,如图4-1所示。

图4-1.ZooKeeper的集群模式

组成ZooKecper集群的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都互相保持着通信。值得一提的是，只要集群中存在超过一半的机器能够正常工作，那么整个集群就能够正常对外服务。

ZooKecper的客户端程序会选择和集群中任意一台机器共同来创建一个TCP连接，而一且客户端和某台ZooKeeper服务器之间的连接断开后，客户端会自动连接到集群中的其他机器。关于ZooKecper客户端的工作原理，将会在7.3节中做详细阐述。

目标三：顺序访问
对于来自客户端的每个更新请求，ZooKecper都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序，应用程序可以使用ZooKecper的这个特性来实现更高层次的同步原语。关于ZooKceper的事务请求处理和事务ID的生成，将会在7.8节中做详细阐述。

目标四：高性能
由于ZooKeeper将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，因此它尤其适用于以读操作为主的应用场景,作者曾经以3台3.4.3版本的ZooKeeper服务器组成集群进行性能压测,100%读请求的场景下压测结果是12-13w的QPS。

4.1.2ZooKeeper从何而来
ZooKeeper最早起源于雅虎研究院的一个研究小组。在当时,研究人员发现,在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调,但是这些系统往往都存在分布式单点问题,所以雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架,以便让开发人员将精力集中在处理业务逻辑上。

关于“Zookeeper”这个项目的名字,其实也有一段趣闻。在立项初期,考虑到之前内部很多项目都是使用动物的名字来命名的(例如著名的Pig项目),雅虎的工程师希望给这个项目也取一个动物的名字,时任研究院的首席科学家RaghuRamakrishnan开玩笑地说:“在这样下去,我们这儿就变成动物园了!”此话一出,大家纷纷表示就叫动物园管理员吧——因为各个以动物命名的分布式组件放在一起,雅虎的整个分布式系统看上去就像一个大型的动物园了,而ZooKeeper正要用来进行分布式环境的协调于是,Zookeeper的名字也就由此诞生了。

4.1.3ZooKeeper的基本概念
本节将介绍ZooKeeper的几个核心概念这些概念贯穿于本书之后对ZooKeeper更深入的讲解,因此有必要预先了解这些概念。

集群角色
通常在分布式系统中,构成一个集群的每一台机器都有自己的角色,最典型的集群模式就是Master/Slave模式(主备模式),在这种模式中,我们把能够处理所有写操作的机器称为Master机器,把所有通过异步复制方式获取最新数据,并提供读服务的机器称为Save机器。

而在ZooKeeper中,这些概念被颠覆了。它没有沿用传统的Master/Slave概念,而是引入了LeaderFollower和Observer三种角色ZooKeeper集群中的所有机器通过一个Leader选举过程来选定一台被称为“Leader”的机器,Leader服务器为客户端提供读和写服务。除Leader外,其他机器包括Follower和Observer.Follower和Observer都能够提供读服务,唯一的区别在于,Observer机器不参与Leader选举过程,也不参与写操作的“过半写成功”策略,因此Observer可以在不影响写性能的情况下提升集群的读性能。关于ZooKeeper的集群结构和各角色的工作原理,将会在7.7节中做详细阐述。

会话（Session)
Session是指客户端会话，在讲解会话之前，我们首先来了解一下客户端连接。在ZooKeeper中，一个客户端连接是指客户端和服务器之间的一个TCP长连接。ZooKeeper对外的服务端口默认是2181，客户端启动的时候，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向ZooKeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。Session的sessionTimeout值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在scssionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效.关于ZooKeeper客户端会话，将会在7.4节中做详细阐述。

数据节点(Znode)
在谈到分布式的时候，我们通常说的“节点”是指组成集群的每一台机器。然面，在ZooKeeper中，“节点”分为两类，第一类同样是指构成集群的机器，我们称之为机器节点：第二类则是指数据模型中的数据单元，我们称之为数据节点—ZNode.ZooKeeper将所有数据存储在内存中，数据模型是一棵树（ZNodeTree)，由斜杠（/）进行分割的路径，就是一个Znode，例如oo/path1.每个ZNode上都会保存自己的数据内容，同时还会保存一系列属性信息。

在ZooKeeper中，ZNode可以分为持久节点和临时节点两类。所谓持久节点是指一且这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在ZooKeeper上.而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。另外，ZooKeeper还允许用户为每个节点漆加一个特殊的属性：SEQUENTIAL.一旦节点被标记上这个属性，那么在这个节点被创建的时候，ZooKeeper会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。
关于ZooKeeper的节点特性以及完整的数据模型，将会在7.1节中做详细闸述。

版本
在前面我们已经提到，ZooKeeper的每个ZNode上都会存储数据，对应于每个ZNode，ZooKeeper都会为其维护一个叫作Stat的数据结构，Stat中记录了这个ZNode的三个数据版本，分别是version（当前ZNode的版本）、cversion(当前ZNode子节点的版本)
和aversion(当前ZNode的ACL版本）.关于ZooKeeper数据模型中的版本，将会在7.13节中做详细阐述。

Watcher
Watcher(事件监听器),是ZooKeeper中的一个很重要的特性,Zookeeper允许用户在指定节点上注册一些Watcher,井且在一些特定事件触发的时候,ZooKeeper服务端会将事件通知到感兴趣的客户端上去,该机制是ZooKeeper实现分布式协调服务的重要特性。美于ZooKeeperWatcher机制的特性和使用,将会在7.14节中做详细阐述。

ACL
ZooKeeper采用ACL（AccessControlLists)策略来进行权限控制，类似于UNIX文件系统的权限控制。ZooKeeper定义了如下5种权限。
	CREATE；创建子节点的权限。
	READ：获取节点数据和子节点列表的权限。
	WRITE:更新节点数据的权限。
	DELETE:删除子节点的权限。
	ADMIN：设置节点ACL的权限。

其中尤其需要注意的是，CREATE和DELETE这两种权限都是针对子节点的权限控制。关于ZooKeeper权限控制的原理和使用方式，将会在7.l.5节中做详细阐述。

4.1.4为什么选择ZooKeeper
在本书引言部分，我们已经讲到，随着分布式架构的出现，越来越多的分布式应用会面临数据一致性问题。很遗憾的是，在解决分布式数据一致性上，除了ZooKeeper之外，目前还没有一个成熟稳定且被大规模应用的解决方案。ZooKeeper无论从性能，易用性还是稳定性上来说，都已经达到了一个工业级产品的标准。

其次，ZooKeeper是开放源代码的，所有人都在关注它的发展，都有权利来贡献自己的力量，你可以和全世界成千上万的ZooKeeper开发者们一起交流使用经验，共同解决问题。

另外，ZooKeeper是免费的，你无须为它支付任何费用。这点对于一个小型公司，尤其是初创团队来说，无疑是非常重要的。

最后.ZooKeeper已经得到了广泛的应用。诸如Hadoop、HBase.Storm和Solr等越来越多的大型分布式项目都已经将ZooKeeper作为其核心组件，用于分布式协调。

4.2ZooKeeper的ZAB协议
在第2.3两拿中，我们已经详细地讲解了其他的分布式一致性协议，在本小节中，我们将围绕ZooKceper官方的儿篇论文资料归来看看ZooKeeper中的一致性协议。

4.2.1ZAB协议
在深入了解ZooKeeper之前，相信很多读者都会认为ZooKeeper就是Paxos算法的一个实现。俱事实上，ZooKeeper并没有完全采用Paxos算法，而是使用了一种称为ZooKeeperAtomicBroadcast(ZAB.ZooKeeper原子消息广播协议）的协议作为其数据一致性的核心算法。

ZAB协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的原子广播协议。ZAB协议的开发设计人员在协议设计之初并没有要求其具有很好的扩展性，最初只是为雅虎公司内部那些高吞吐量、低延迟、健壮，简单的分布式系统场景设计的，在ZooKeeper的官方文档中也指出，ZAB协议并不像Paxos算法那样，是一种通用的分布式一致性算法，它是一种特别为ZooKeeper设计的满溃可恢复的原子消息广播算法。

在ZooKeeper中，主要依翰ZAB协议来实现分布式数据一致性，基于该协议，ZooKeeper实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。具体的，ZooKeeper使用一个单一的主进程来接收并处理客户端的所有事务请求，并采用ZAB的原子广播协议，将服务器数据的状态变更以事务Proposal的形式广播到所有的副本进程上去。ZAB协议的这个主备模型架构保证了同一时刻集群中只能够有一个主进程来广播服务器的状态变更，因此能够很好地处理客户端大量的并发请求。另一方面，考虑到在分布式环境中，顺序执行的一些状态变更其前后会存在一定的依赖关系，有些状态变更必须依赖于比它早生成的那些状态变更，例如变更C需要依赖变更A和变更B.这样的依赖关系也对ZAB协议提出了一个要求：ZAB协议必须能够保证一个全局的变更序列被顺序应用，也就是说，ZAB协议需要保证如果一个状态变更已经被处理了，那么所有其依赖的状态变更都应该已经被提前处理掉了。最后，考虑到主进程在任何时候都有可能出现崩溃退出或重启现象,因此,ZAB协议还需要做到在当前主进程出现上述异常情况的时候,依旧能够正常工作。

ZAB协议的核心是定义了对于那些会改变ZooKeeper服务器数据状态的事务请求的处理方式,即：

所有事务请求必须由一个全局唯一的服务器来协调处理,这样的服务器被称为Leader服务器,而余下的其他服务器则成为Follower服务Leader服务器负责将一个客户端事务请求转换成一个事务Proposal(提议),并将该Proposal分发给集群中所有的FollowerLeader服务器,之后服务器需要等待所有Follower服务器的反馈,一旦超过半数的Follower服务器进行了正确的反馈后那么Leader就会再次向所有的Follower服务器分发Commit消息,要求其将前一个Propoul进行提交。

4.2.2协议介绍
从上面的介绍中，我们已经了解了ZAB协议的核心，现在我们就来详细地讲解下ZAB协议的具体内容。ZAB协议包括两种基本的模式，分别是崩溃恢复和消息广播。当整个服务框架在启动过程中，或是当Leader服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB协议就会进入恢复模式并选举产生新的Leader服务器。当选举产生了新的Leader服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。

当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。当一台同样遵守ZAB协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。正如上文介绍中所说的，ZooKeeper设计成只允许唯一的一个Lcader服务器来进行事务请求的处理。Lcader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议，而如果集群中的其他机器接收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。

当Leader服务器出现崩溃退出或机器重启，亦或是集群中已经不存在过半的服务器与该Leader服务器保持正常通信时，那么在重新开始新一轮的原子广播事务操作之前，所有进程首先会使用崩溃恢复协议来使彼此达到一个一致的状态，于是整个ZAB流程就会从消息广播模式进入到淌溃恢复模式。

一个机器要成为新的Leader,必须获得过半进程的支持,同时由于每个进程都有可能会崩溃,因此,在ZAB协议运行过程中,前后会出现多个Leader,并且每个进程也有可能会多次成为Leader进入崩溃恢复模式后,只要集群中存在过半的服务器能够彼此进行正常通信,那么就可以产生一个新的Leader并再次进入消息广播模式举个例子来说,一个由3台机器组成的ZAB服务,通常由1个Leader,2个Follower服务器组成某一个时刻,假如其中一个Follower服务器挂了,整个ZAB集群是不会中断服务的,这是因为Leader服务器依然能够获得过半机器(包括Leader自己)的支持。

接下来我们就重点讲解一下ZAB协议的消息广播和崩溃恢复过程。

消息广播

ZAB协议的消息广播过程使用的是一个原子广播协议,类似于一个二阶段提交过程针对客户端的事务请求,Leader服务器会为其生成对应的事务Proposal,并将其发送给集群中其余所有的机器,然后再分别收集各自的选票,最后进行事务提交,如图42所示就是ZAB协议消息广播流程的示意图。

图4-2.ZAB协议消息广播流程示意图

在第2章中，我们已经详细讲解了关于二阶段提交协议的内容，而此处ZAB协议中涉及的二阶段提交过程则与其略有不同。在ZAB协议的二阶段提交过程中，移除了中断逻辑，所有的Follower服务器要么正常反铺Leader提出的事务Proposal，要么就抛弃Leader服务器。同时，ZAB协议将二阶段提交中的中断逻辑移除意味着我们可以在过半的Follower服务器已经反馈Ack之后就开始提交事务Proposal了，而不需要等待集群中所有的Follower服务器都反馈响应。当然，在这种简化了的二阶段提交模型下，是无法处理Lcader服务器崩溃退出而带来的数据不一致问题的，因此在ZAB协议中添加了另一个模式，即采用崩溃恢复模式来解决这个问题。另外，整个消息广播协议是基于具有FIFO特性的TCP协议来进行网络通信的，因此能够很容易地保证消息广播过程中消息接收与发送的顺序性。

在整个消息广播过程中,Leader服务器会为每个事务请求生成对应的Proposal来进行厂播,并且在广播事务Proposal之前,Leader服务器会首先为这个事务Proposa分配一个全局单调递增的唯一1D,我们称之为事务1D(即ZXD)。由于ZAB协议需要保证每一个消息严格的因果关系,因此必须将每一个事务Proposal按照其ZXID的先后顺序来进行排序与处理。

具体的,在消息广播过程中,Leader服务器会为每一个Follower服务器都各自分配一个单独的队列,然后将需要广播的事务Proposal依次放入这些队列中去,并且根据FFO策路进行消息发送。每一个Follower服务器在接收到这个事务Proposal之后,都会首先将其以事务日志的形式写入到本地磁盘中去,并且在成功写入后反馈给Leader服务器一个Ack响应,当Leader服务器接收到超过半数Follower的Ack响应后,就会广播一个Commit消息给所有的Follower服务器以通知其进行事务提交,同时Leader自身也会完成对事务的提交,而每一个Follower服务器在接收到Commit消息后,也会完成对事务的提交。

崩溃恢复

上面我们主要讲解了ZAB协议中的消息广播过程。ZAB协议的这个基于原子广播协议的消息广播过程,在正常情况下运行非常良好,但是一且Leader服务器出现崩溃,或者说由于网络原因导致Leader服务器失去了与过半Follower的联系,那么就会进入崩溃恢复模式。在ZAB协议中,为了保证程序的正确运行,整个恢复过程结束后需要选举出一个新的Leader服务器。因此,ZAB协议需要一个高效且可靠的Leader选举算法,从而确保能够快速地选举出新的Leader,同时,Leader选举算法不仅仅需要让Leader自己知道其自身已经被选举为Leader,同时还需要让集群中的所有其他机器也能够快速地感知到选举产生的新的Leader服务器。

基本特性

根据上面的内容,我们了解到,ZAB协议规定了如果一个事务Proposal在一台机器上被处理成功,那么应该在所有的机器上都被处理成功,哪怕机器出现故障崩溃。接下来我们看看在崩溃恢复过程中,可能会出现的两个数据不一致性的隐患及针对这些情况ZAB协议所需要保证的特性。

ZAB协议需要确保那些已经在Leader服务器上提交的事务最终被所有服务器都提交

假设一个事务在Leader服务器上被提交了,并且已经得到过半Follower服务器的Ack反馈,但是在它将Commit消息发送给所有Follower机器之前,Leader服务器挂了,如图43所示。

图4-3.崩溃恢复过程需要确保已经被Leader提交的Proposal也能够被所有的Follower提交

图4-3中的消息C2就是一个典型的例子：在集群正常运行过程中的某一个时刻。
Serverl是Leader服务器，其先后广播了消息Pl、P2、Cl、P3和C2，其中，当
Leader服务器将消息C2（C2是CommitOfProposal2的缩写，即提交事务Proposal2）
发出后就立即崩溃退出了。针对这种情况，ZAB协议就需要确保事务Proposal2最
终能够在所有的服务器上都被提交成功，否则将出现不一致。

ZAB协议需要确保丢升那些只在Leader服务器上被提出的事务

相反，如果在崩灌恢复过程中出现一个需要被丢弃的提案，那么在崩清恢复结束后
需要跳过该事务Proposal，如图4-4所示。

图44.崩澳恢复过程需要跳过那些已经被丢弃的事务Proposal

在图4-4所示的集群中,假设初始的LeaderServerl服务器在提出了一个事务Proposal33之后就崩清退出了,从而导致集群中的其他服务器都没有收到这个事务Proposal.于是,当Server恢复过来再次加入到集群中的时候,ZAB协议需要确保丢弃Proposal33这个事务。

结合上面提到的这两个崩溃恢复过程中需要处理的特殊情况,就决定了ZAB协议必须设计这样一个Leader选举算法:能够多确保提交已经被Leader提交的事务Proposal,同时丢弃已经被跳过的事务Proposal,针对这个要求,如果让Leade选举算法能够保证新选举出来的Leader服务器拥有集群中所有机器最高编号(即ZXD最大)的事务Proposal那么就可以保证这个新选举出来的Leader一定具有所有已经提交的提案,更为重要的是如果让具有最高编号事务Proposa的机器来成为Leader,就可以省去Leader服务器检查Proposa的提交和丢弃工作的这一步操作了。

数据同步

完成Leader选举之后,在正式开始工作(即接收客户端的事务请求,然后提出新的提案)之前,Leader服务器会首先确认事务日志中的所有Proposa是否都已经被集群中过半的机器提交了,即是否完成数据同步。下面我们就来看看ZAB协议的数据同步过程。

所有正常运行的服务器,要么成为Leader,要么成为Follower井和Leader保持同步Leader服务器需要确保所有的Follower服务器能够接收到每一条事务Proposal,井且能够正确地将所有已经提交了的事务Proposa应用到内存数据库中去,具体的,Leader服务器会为每一个Follower服务器都淮备一个队列,并将那些没有被各Follower服务器同步的事务以Proposal消息的形式逐个发送给Follower服务器,并在每一个Proposal消息后面紧接着再发送一个Commit消息,以表示该事务已经被提交。等到Follower服务器将所有其尚未同步的事务Proposal都从Leader服务器上同步过来井成功应用到本地数据库中后,Leader服务器就会将该Follower服务器加入到真正的可用Follower列表中井开始之后的其他流程。

上面讲到的是正常情况下的数据同步逻辑,下面来看ZAB协议是如何处理那些需要被丢弃的事务Proposal的,在ZAB协议的事务编号ZXID设计中,ZXID是一个64位的数字,其中低32位可以看作是一个简单的单调递增的计数器,针对客户端的每一个事务请求,Leader服务器在产生一个新的事务Proposal的时候,都会对该计数器进行加1操作:而高32位则代表了Leader周期epoch的编号,每当选举产生一个新的Leader服务器,就会从这个Leader服务器上取出其本地日志中最大事务Proposal的ZXID,并从该ZXID中解析出对应的epoch值,然后再对其进行加I操作,之后就会以此编号作为新的epoch,井将低32位置0来开始生成新的ZXID.ZAB协议中的这一通过epoch编号来区分Leader周期变化的策略,能够有效地避免不同的Leader服务器错误地使用相同的ZXID编号提出不一样的事务Proposal的异常情况,这对于识别在Leader崩溃恢复前后生成的Proposal非常有帮助,大大简化和提升了数据恢复流程。

基于这样的策略,当一个包含了上一个Leader周期中尚未提交过的事务Proposal的服务器启动时,其肯定无法成为Leader,原因很简单,因为当前集群中一定包含一个Quorum集合,该集合中的机器一定包含了更高epoch的事务Proposal,因此这台机器的杯务Proposal肯定不是最高,也就无法成为Leader了。当这台机器加入到集群中,以Follower角色连接上Leader服务器之后，Leader服务器会根据自己服务器上最后被提交的Proposal来和Follower服务器的Proposal进行比对，比对的结果当然是Leader会要求Follower进行一个回退操作—回退到一个确实已经被集群中过半机器提交的最新的事务Proposal.举个例子来说，在图44中，当Serverl连接上Leader后，Leader会要求Serverl去除P3。

4.2.3深入ZAB协议
在4.2.2节中，我们已经基本介绍了ZAB协议的大体内容以及在实际运行过程中消息广播和崩遗恢复这两个基本的模式，下面将从系统模型、问题描述、算法描述和运行分析四方面来深入了解ZAB协议。

系统模型
在深入讲解ZAB协议之前，我们先来抽象地描述下ZAB协议需要构建的分布式系统模型。通常在一个由一组进程Ⅱ=|P.P2..….P..组成的分布式系统中，其每一个进程都具有各自的存储设备，各进程之间通过相互通信来实现消息的传递。一般的，在这样的一个分布式系统中，每一个进程都随时有可能会出现一次或多次的崩溃退出，当然，这些进程会在恢复之后再次加入到进程组门中去。如果一个进程正常工作，那么我们称该进程处于UP状态：如果一个进程崩遗了，那么我们称其处于DOWN状态。事实上，当集群中存在过半的处于UP状态的进程组成一个进程子集之后，就可以进行正常的消息广播了。我们将这样的一个进程子集称为Quorum（下文中使用“Q”来表示)，并假设这样的Q已经存在，其满足：

Avo,ocl
Avo和Q,0:nQtO

上述集合关系式表示，存在这样的一个进程子集Q，其必定是进程组口的子集；同时，存在任意两个进程子集Q1和Q2，其交集必定非空。

我们使用P，和P,来分别表示进程组口中的两个不同进程，使用C，来表示进程P,和,之间的网络通信通道，其满足如下两个基本特性。

完整性（Integrity）
进程P，如果收到来自进程P的消息m，那么进程P，一定确实发送了消息m。

前置性(Prefix)
如果进程P收到了消息m,那么存在这样的消息m':如果消息m是消息m的前置消息,那么P务必先接收到消息m,然后再接收到消息m。我们将存在这种前置性关系的两个消息表示为:m<m,前置性是整个协议设计中最关键的一点,由于每一个消息都有可能是基于之前的消息来进行的,因此所有的消息都必须按照严格的先后顺序来进行处理。

问题描述
在了解了ZAB协议所针对应用的系统模型后，我们再来看看其所要解决的实际分布式问题。在前文的介绍中，我们已经了解到Zo0Keeper是一个高可用的分布式协调服务，在雅虎的很多大型系统上得到应用，这类应用有个共同的特点，即通常都存在大量的客户端进程，并且都依赖ZooKeeper来完成一系列请如可靠的配置存储和运行时状态记录等分布式协调工作。鉴干这些大型应用对ZooKceper的依赖，因此Zookeeper必须具备高吞吐和低延迟的特性，并且能够很好地在高并发情况下完成分布式数据的一致性处理，同时能够优雅地处理运行时故障，并具备快速地从故障中恢复过来的能力。

ZAB协议是整个ZooKeeper框架的核心所在，其规定了任何时候都需要保证只有一个主进程负责进行消息广播，而如果主进程崩遗了，就需要选举出一个新的主进程。主进程的选举机制和消息广播机制是紧密相关的。随着时间的推移，会出现无限多个主进程井构成一个主进程序列：P1.P2….Pe1.P..其中P.el.e表示主进程序列号，也被称作主进程周期。对于这个主进程序列上的任意两个主进程来说，如果c小于”，那么我们就说P.是P.之前的主进程，通常使用P.<P来表示。需要注意的是，由于各个进程都会发生崩遗然后再次恢复，因此会出现这样的情况：存在这样的P.和P.，它们本质上是同一个进程，只是处于不同的周期中而已。

主进程周期
为了保证主进程每次广播出来的事务消息都是一致的，我们必须确保ZAB协议只有在充分完成崩溃恢复阶段之后，新的主进程才可以开始生成新的事务消息广播。为了实现这个目的，我们假设各个进程都实现了类似于ready(e)这样的一个函数调用，在运行过程中，ZAB协议能够非常明确地告知上层系统（指主进程和其他副本进程）是否可以开始进行事务消息的广播，同时，在调用ready(e)函数之后，ZAB还需要为当前主进程设置一个实例值。实例值用于唯一标识当前主进程的周期，在进行消息广播的时候，主进程使用该实例值来设置事务标识中的epoch字段—当然，ZAB需要保证实例值在不同的主进程周期中是全局唯一的。如果一个主进程周期e早于另一个主进程周期c，那么将其表示为e<e。

事务
我们假设各个进程都存在一个类似于transactions(\,x)这样的函数调用,来实现主进程对状态变更的广播。主进程每次对transaction(vz)函数的调用都包含了两个字段:事务内容v和事务标识z,而每一个事务标识z=<>也包含两个组成部分,前者是主进程周期e,后者是当前主进程周期内的事务计数c。我们使用epoch(z)来表示一个事务标识中的主进程周期epoch,使用counter(x)来表示事务标识中的事务计数。

针对每一个新的事务,主进程都会首先将事务计数c递增。在实际运行过程中,如果一个事务标识z优先于另一个事务标识x,那么就有两种情况:一种情况是主进程周期不同,即epoch(a)<epoch(z)另一种情况则是主进程周期一致,但是事务计数不同即epoch(z)=epoch(z)且counter(z)<counter(z),无论哪种情况,均使用z<:z来表示。

算法描述

下面我们将从算法描述角度来深入讲解ZAB协议的内部原理。整个ZAB协议主要包括消息广播和崩溃恢复两个过程,进一步可以细分为三个阶段,分别是发现(Discovery)同步(Synchronization)和广播(Broadcast)阶段,组成ZAB协议的每一个分布式进程会循环地执行这三个阶段,我们将这样一个循环称为一个主进程周期。

为了更好地对ZAB协议各阶段的算法流程进行描述,我们首先定义一些专有标识和术语,如表41所示。

表4-1.zAB协议算法表述术语介绍

术语名说明
F.pFollowerf处理过的最后一个事务Proposal

Followerf处理过的质史事备Proposul中最后一个事素Proposal的事青标识ZXID

每一个Followerf通常都已经处理（提受）了不少事身Proposal，并且会有一个针对已经处理过的事务的集合，将其表而为hr，表示Followerf已经处理过的事务序列

I.初始化两支记象，在某一个主进很周期cpoche中，当准Leader完点阶段一之后，此时它的hr就就梯记为1，关于ZAB协议的阶段一过往，将在下文中做详细讲解

下面我们就从发现、同步和广播这三个阶段展开来讲解ZAB协议的内部原理。

阶段一：发现
阶段一主要就是Leader选举过程，用于在多个分布式进程中选举出主进程，准LeaderL和FollowerF的工作流程分别如下。

步骤F.1.1FollowerF将自己最后接受的事务Proposal的epoch值CEPOCH（Fn）发送
给准LeaderL。

步骤L1.1当接收到来自过半Follower的CEPOCH（F,）消息后，准LeaderL会生成
NEWEPOCH(e)消息给这些过半的Follower。

关于这个epoch值e'，准LeaderL会从所有接收到的CEPOCH（F。）消息中
选取出最大的epoch值，然后对其进行加l操作，即为e'。

步骤F.1.2当Follower接收到来自准LeaderL的NEWEPOCH(e)消息后，如果其检
测到当前的CEPOCH(F)值小于e'，那么就会将CEPOCH（Fp）赋值为e'，
同时向这个准LeaderL反馈Ack消息。在这个反馈消息（ACK-E（F.p-h))
中，包含了当前该Follower的epochCEPOCH(F7)，以及该Follower的历
史事务Proposal集合：h。

当LeaderI接收到来自过半Follower的确认消息Ack之后,LeaderL就会从这过半服务器中选取出一个FollowerH,井使用其作为初始化事务集合L

关于这个FollowerF的选取,对于Quorum中其他任意一个FollowerI,F需要满足以下两个条件中的一个:
CEPOCH(F)<CEPOCH(Fp)
CEPOCH(F)=CEPOCH(F→)&(Fm<:FaM或F=F=a)
至此,ZAB协议完成阶段一的工作流程。

阶段二:同步
在完成发现流程之后,就进入了同步阶段。在这一阶段中,LeaderL和FollowerF的工作流程分别如下。

步骤L.2.1LeaderL会将e和le'以NEWLEADER(C'.1.)消息的形式发送给所有Quorum
中的Follower。

步骤F.2.1当Follower接收到来自LeaderL的NEWLEADER(e,1)消息后，如果
Follower发现CEPOCH(F.)#e，那么直接进入下一轮循环，因为此时
Follower发现自己还在上一轮，或者更上轮，无法参与本轮的同步。

如果CEPOCH(F，)=e，那么Follower就会执行事务应用操作。具体的，
对于每一个事务Proposal:<v.z>el,，Follower都会接受<e<V，z>>。

最后,Follower会反馈给Leader,表明自己已经接受井处理了所有L中的事务Proposal。

步骤L2.2当Leader接收到来自过半Follower针对NEWLEADERe)的反馈消息后,就会向所有的Follower发送Commit息。至此Leader完成阶段二。

步骤F2.2当Follower收到来自Leader的Commit消息后,就会依次处理并提交所有在1中未处理的事务。至此Follower完成阶段二。

阶段三：广播
完成同步阶段之后，ZAB协议就可以正式开始接收客户端新的事务请求，并进行消息广播流程。

步骤L.3.ILeaderL接收到客户端新的事务请求后,会生成对应的事务Proposal,井根据ZXID的顺序向所有Follower发送提案<e<vz>,其中epoch(z)=e。

步骤F3.1Follower根据消息接收的先后次序来处理这些来自Leader的事务Proposal,井将他们追加到h中去,之后再反馈给Leader。

步骤L3.1当Leader接收到来自过半Follower针对事务Proposal<e:<v,z>的Ack消息后,就会发送Commit<e,<v,z>>消息给所有的Follower,要求它们进行事务的提交。

步骤F3.2当FollowerF接收到来自Leader的Commit<e,<v,z>消息后,就会开始提交事务Proposa<e,<v,z>,需要注意的是,此时该FollowerF必定已经提交了事务Proposal<v,z'>,其中<v,z>∈h,z'<xz。

以上就是整个ZAB协议的三个核心工作流程,如图45所示是在整个过程中各进程之间的消息收发情况,各消息说明依次如下:

CEPOCHFollower进程向准Leader发送自己处理过的最后一个事务Proposal的epoch值。

NEWEPOCH:准Leader进程根据接收的各进程的epoch,来生成新一轮周期的epoch值。

Ack-e:Follower进程反馈准Leader进程发来的NEWEPOCH消息。

NEWLEADER:准Leader进程确立自己的领导地位,并发送NEWLEADER消息给各进程。

Ack-ld:Follower进程反馈Leader进程发来的NEWLEADER消息。

COMMrT-LD：要求Follower进程提交相应的历史事务Proposal。

PROPOSE:Leader进程生成一个针对客户端事务请求的Proposal。

ACK：Follower进程反馈Leader进程发来的PROPOSAL消息。

COMMIT：Leader发送COMMIT消息，要求所有进程提交事务PROPOSE。

在正常运行过程中，ZAB协议会一直运行于阶段三来反复地进行消息广播流程。如果出现Leader崩或其他原因导致Leader缺失，那么此时ZAB协议会再次进入阶段一，重新选举新的Lcader。

图4-5.ZAB协议算法描述示意图

运行分析
在ZAB协议的设计中,每一个进程都有可能处于以下三种状态之一。

LOOKING:Leader选举阶段
FOLLOWING:FollowerLeader服务器和保持同步状态
LEADING:Leader服务器作为主进程领导状态

组成ZAB协议的所有进程启动的时候,其初始化状态都是LOOKING状态,此时进程组中不存在Leader所有处于这种状态的进程,都会试图去选举出一个新的Leader随后,如果进程发现已经选举出新的Leader了,那么它就会马上切换到FOLLOWING状态,并开始和Leader保持同步,这里,我们将处于FOLLOWING状态的进程称为Follower将处于LEADING状态的进程称为Leader.考虑到Leader进程随时会挂掉,当检测出Leader已经崩遗或者是放弃了领导地位时，其余的Follower进程就会转换到LOOKING状态，并开始进行新一轮的Leader选举。因此在ZAB协议运行过程中，每个进程都会在LEADING,FOLLOWING和LOOKING状态之间不断地转换。

Leader的选举过程发生在前面两个阶段。图4+-5展示了在一次Leader选举过程中，各进程之间的消息发送与接收情况。需要注意的是，只有在完成了阶段二，即完成各进程之间的数据同步之后，准Leader进程才能真正成为新的主进程周期中的Leader.具体的，我们将一个可用的Leader定义如下：

如果一个准LeaderL接收到来自过半的Follower进程针对L。的NEWLEADER(e.1.)反馈消息，那么L。就成为了周期e的Leader。

完成Leader选举以及数据同步之后，ZAB协议就进入了原子广播阶段。在这一阶段中，Leader会以队列的形式为每一个与自己保持同步的Follower创建一个操作队列。同一时刻，一个Follower只能和一个Leader保持同步，Leader进程与所有的Follower进程之间都通过心跳检渊机制来感知彼此的情况。如果Leader能够在超时时间内正常收到心跳检测，那么Follower就会一直与该Leader保持连接。而如果在指定的超时时间内Leader无法从过半的Follower进程那里接收到心跳检渊，或者是TCP连接本身断开了，那么Leader就会终止对当前周期的领导，并转换到LOOKING状态，所有的Follower也会选择放弃这个Leader，同时转换到LOOKING状态。之后，所有进程就会开始新一轮的Leader选举，并在选举产生新的Leader之后开始新一轮的主进程周期。

4.2.4ZAB与Paxos算法的联系与区别

ZAB协议并不是Paxos算法的一个典型实现，在讲解ZAB和Paxos之间的区别之前，我们首先来看下两者的联系。

两者都存在一个类似于Leader进程的角色，由其负责协调多个Follower进程的运行。
Leader进程都会等待超过半数的Follower做出正确的反馈后，才会将一个提案进行提交。
在ZAB协议中，每个Proposal中都包含了一个epoch值，用来代表当前的Leader周期，在Paxos算法中，同样存在这样的一个标识，只是名字变成了Ballot。

在Paxos算法中，一个新选举产生的主进程会进行两个阶段的工作。第一阶段被称为读阶段，在这个阶段中，这个新的主进程会通过和所有其他进程进行通信的方式来收集上一个主进程提出的提案，并将它们提交。第二阶段被称为写阶段，在这个阶段，当前主进程开始提出它自己的提案。在Paxos算法设计的基础上，ZAB协议额外添加了一个同步阶段。在同步阶段之前，ZAB协议也存在一个和Paxos算法中的读阶段非常类似的过程，称为发现（Discovery)阶段。在同步阶段中，新的Leader会确保存在过半的Follower已经提交了之前Leader周期中的所有事务Proposal。这一同步阶段的引入，能够有效地保证Leader在新的周期中提出事务Proposal之前，所有的进程都已经完成了对之前所有事务Proposal的提交。一旦完成同步阶段后，那么ZAB就会执行和Paxos算法类似的写阶段。

总的来讲，ZAB协议和Paxos算法的本质区别在于，两者的设计目标不太一样。ZAB协议主要用于构建一个高可用的分布式数据主备系统，例如ZooKceper，而Paxos算法则是用于构建一个分布式的一致性状态机系统。

小结

本章从介绍ZooKeeper开始，向读者初步讲解了ZooKeeper的设计目标、由来以及基本概念。同时，本章也详细地介绍了ZooKeeper的一致性协议—ZAB，并将其与Paxos算法进行了对比。对于ZooKeeper中ZAB协议的具体实现，将会在7.8节中进行更为详细的讲解。