第四章ZooKeeper与Paxos

ApacheZooKeeper是由ApacheHadoop的子项目发展而来,于2010年11月正式成为了Apache的顶级项目。ZooKeeper为分布式应用提供了高效且可靠的分布式协调服务,提供了诸如统一命名服务、配置管理和分布式锁等分布式的基础服务。在解决分布式数据一致性方面,ZooKeeper并没有直接采用Paxos算法,而是采用了一种被称为B(ZooKeeperAtomicBroadcast)的一致性协议。

在本章中,我们将首先对ZooKeeper进行一个整体上的介绍,包括ZooKeeper的设计目标,由来以及它的基本概念,然后将会重点介绍ZAB这一ZooKeeper中非常重要的一致性协议。

4.1初ZooKeeper识
在本节中,我们会对ZooKeeper进行一个初步的介绍,从ZooKeeper是什么、Zookeeper的由来及其基本概念展开,同时会向读者介绍使用ZooKeeper来解决分布式一致性问题的优势。

4.1.1ZooKeeper介绍
ZooKeeper是一个开放源代码的分布式协调服务,由知名互联网公司雅虎创建,是GoogleChubby的开源实现ZooKeeper的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来,构成一个高效可靠的原语集,并以一系列简单易用的接口提供给用户使用。

ZooKeeper是什么
ZooKeeper是一个典型的分布式数据一致性的解决方案,分布式应用程序可以基于它实现诸如数据发布/了阅，负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能.ZooKeeper可以保证如下分布式一致性特性。

顺序一致性
从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到
ZooKeeper中去。

原子性
所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说。
要么整个集群所有机器都成功应用了某一个事务，要么都没有应用，一定不会出现
集群中部分机器应用了该事务，而另外一部分没有应用的情况。

单一视图（SingleSystemlmage）
无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。

可靠性
一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么么该事务所引起的
服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。

实时性
通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立
即从服务端上读取到这个事务变更后的最新数据状态，这里需要注意的是，
ZooKecper仪仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最
新的数据状态。

ZooKeeper的设计目标
ZooKeeper致力于提供一个高性能高可用,且具有严格的顺序访问控制能力(主要是写操作的严格顺序性)的分布式协调服务。高性能使得ZooKeeper能够应用于那些对系统吞吐有明确要求的大型分布式系统中,高可用使得分布式的单点问题得到了很好的解决,而严格的顺序访问控制使得客户端能够基于ZooKeeper实现一些复杂的同步原语下面我们来具体看一下ZooKeeper的四个设计目标。

目标一:简单的数据模型
ZooKeeper使得分布式程序能够通过一个共享的,树型结构的名字空间来进行相互协调。这里所说的树型结构的名字空间,是指ZooKeeper服务器内存中的一个数据模型,其由一系列被称为ZNode的数据节点组成,总的来说,其数据模型类似于一个文件系统,而ZNode之间的层级关系,就像文件系统的目录结构一样。不过和传统的磁盘文件系统不同的是,ZooKeeper将全量数据存储在内存中,以此来实现提高服务器吞吐、减少延迟的目的。关于Zookeeper的数据模型,将会在7.L.1节中做详细阐述。

目标二:可以构建集群
一个ZooKeeper集群通常由一组机器组成,一般3-5台机器就可以组成一个可用的ZooKeeper集群了,如图4-1所示。

图4-1.ZooKeeper的集群模式

组成ZooKecper集群的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都互相保持着通信。值得一提的是，只要集群中存在超过一半的机器能够正常工作，那么整个集群就能够正常对外服务。

ZooKecper的客户端程序会选择和集群中任意一台机器共同来创建一个TCP连接，而一且客户端和某台ZooKeeper服务器之间的连接断开后，客户端会自动连接到集群中的其他机器。关于ZooKecper客户端的工作原理，将会在7.3节中做详细阐述。

目标三：顺序访问
对于来自客户端的每个更新请求，ZooKecper都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序，应用程序可以使用ZooKecper的这个特性来实现更高层次的同步原语。关于ZooKceper的事务请求处理和事务ID的生成，将会在7.8节中做详细阐述。

目标四：高性能
由于ZooKeeper将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，因此它尤其适用于以读操作为主的应用场景,作者曾经以3台3.4.3版本的ZooKeeper服务器组成集群进行性能压测,100%读请求的场景下压测结果是12-13w的QPS。

4.1.2ZooKeeper从何而来
ZooKeeper最早起源于雅虎研究院的一个研究小组。在当时,研究人员发现,在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调,但是这些系统往往都存在分布式单点问题,所以雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架,以便让开发人员将精力集中在处理业务逻辑上。

关于“Zookeeper”这个项目的名字,其实也有一段趣闻。在立项初期,考虑到之前内部很多项目都是使用动物的名字来命名的(例如著名的Pig项目),雅虎的工程师希望给这个项目也取一个动物的名字,时任研究院的首席科学家RaghuRamakrishnan开玩笑地说:“在这样下去,我们这儿就变成动物园了!”此话一出,大家纷纷表示就叫动物园管理员吧——因为各个以动物命名的分布式组件放在一起,雅虎的整个分布式系统看上去就像一个大型的动物园了,而ZooKeeper正要用来进行分布式环境的协调于是,Zookeeper的名字也就由此诞生了。

4.1.3ZooKeeper的基本概念
本节将介绍ZooKeeper的几个核心概念这些概念贯穿于本书之后对ZooKeeper更深入的讲解,因此有必要预先了解这些概念。

集群角色
通常在分布式系统中,构成一个集群的每一台机器都有自己的角色,最典型的集群模式就是Master/Slave模式(主备模式),在这种模式中,我们把能够处理所有写操作的机器称为Master机器,把所有通过异步复制方式获取最新数据,并提供读服务的机器称为Save机器。

而在ZooKeeper中,这些概念被颠覆了。它没有沿用传统的Master/Slave概念,而是引入了LeaderFollower和Observer三种角色ZooKeeper集群中的所有机器通过一个Leader选举过程来选定一台被称为“Leader”的机器,Leader服务器为客户端提供读和写服务。除Leader外,其他机器包括Follower和Observer.Follower和Observer都能够提供读服务,唯一的区别在于,Observer机器不参与Leader选举过程,也不参与写操作的“过半写成功”策略,因此Observer可以在不影响写性能的情况下提升集群的读性能。关于ZooKeeper的集群结构和各角色的工作原理,将会在7.7节中做详细阐述。